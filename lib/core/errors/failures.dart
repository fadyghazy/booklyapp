import 'package:dio/dio.dart';
import 'package:flutter/material.dart';

abstract class Failure{
  // ودى معناها ان كل failure حيكون له error message خاصه بيه حتظهر لل user
  final String errorMessage;
   const Failure(this.errorMessage);
}
class ServerFailure extends Failure {
  ServerFailure(super.errorMessage);

  factory ServerFailure.fromDioError(DioError dioError){
    // Create Server From Dio Error 
    switch (dioError.type) {
      case DioErrorType.connectTimeout:
      // فى هدة الحاله انت عملت request بس خد وقت كبير جدا عشان يعمل connection فبالتالى حصل timeout
        return ServerFailure('Connection timeout with ApiServer');
    // ودى معناها ان حيظهر لل user رساله ان حصل timeout واحنا بنعمل connect على الapiserver
      case DioErrorType.sendTimeout:
      // فى الحاله دى انت بتبعت البيانات وفضل يبعت لفترة طويله جدا ومبعتش حاجه فى الاخر فبالتالى حصل ودى ممكن تكون مشكله فى الnetwork  timeout
        return ServerFailure('Send timeout with ApiServer');
      case DioErrorType.receiveTimeout:
        return ServerFailure('Receive timeout with ApiServer');

      case DioErrorType.response:
      // دى فى حاله ان رد عليك ب response يعنى كدة انت راجعلك status code ومعاة  ممكن يرجعلك response لان بعض الاوقات ممكن ميرجعلكش response زى مثلا 400 دة badrequest ودة معناة ان فيه مشكله فى الrequest و401 دة فيه مشكله فى الunauthorized يعنى تقريبا فيه مشكله فى الauthentication اللى بيعملها ال user  و 403 دة  forbidden ودى حاجه زى ال401  وعندك بقى فى حاله ال404 ودى معناها ان فيه عندك مشكله فى الrequest اللى بتحاول تعمله access  وهنا فى الRequest دة مبيرجعلكش response اصلا فانت فى حاله ال404 ممكن ميرجعلكش response والmessage انت عارفها ان الrequest  not Found بينما ال400 و 401 وال 403 بيرجعولك response عادى برسائل مختلفه فيالتالى بيقولك كدة انت راجعلك حاجه يعنى راجعلك response وراجعلك status code ممكن تستخدمهم
      // انا اللى يهمنى فى حاله الresponse انى اشوف الstatus code بتاعى وعلى اساس الstatus code دة لو كان 400 او 401 او 403 هنا حعمل parse لل response اللى راجعلى ولو كان حاجه غير كدة فانا مش حعمل parse وساعتها حرجع message مختلفه شويه
        return ServerFailure.fromResponse(dioError.response!.statusCode!,dioError.response!.data);
      case DioErrorType.cancel:
        return ServerFailure('Request to ApiServer was Canceled');
      // هنا cancel يعنى العمليه اتعملها cancel
        break;
      case DioErrorType.other:
        if(dioError.message.contains('SocketException')){
          return ServerFailure('No Internet Connection ');
          // هنا مفيش net اساسا
        }
        return ServerFailure('UnExpected Error,Please Try again   ');
      default:return ServerFailure('Opps There was an Error,please try again');
        // هنا احنا عملنا handle لكل الcases فكدة اصبح عندك server failure متهندل فيه كل cases
        // كدة فاضل الdafault case لان ممكن ولا واحدة من دول تحصل فلو ولا واحدة من ال cases  حصلت  ومعملتش ال  default case حتبقى مشكله لينا

    // فى هدة الحاله احنا مش عارفين ايه ال failure اللى حصل اساسا
          // وفى الحاله دى  حعمل check على نقطه بسيطه وهى  ان فى الdio error حقوله ال message تحتوى على Socket Exception لان فى حاله الother على حسب الdocumentation فممكن يكون فيه Socket Exception والSocket Exception دى معناها ان مفيش Network اصلا يعنى انت عملت Request ومفيش Network فهو رد عليك بال Exception دة فطبعا فى الحاله دى الmessage  حت contain  Socket Exception

    // هنا انا بستعمل ال factory constructor عشان اقدر ا handle ال cases الخاصه بال dio errors اللى بتجيلى من الdio
    }

  }

  factory ServerFailure.fromResponse(int statusCode,dynamic response){
    //هنا انا بستقبل ال statuscode وال response الخاص بال dio error  لان انا محتاجهم
    // هنا انا حعمل  check على الstatuscode سواء كانت 400 او 401 او 403 فى هدة الحالات بعمل Parse ل response
    if(statusCode==400||statusCode==401||statusCode==403){
      return ServerFailure(response['error']['message']);
      // بداخل ال server failure ححط ال message بتاعتى على حسب ال response اللى راجعلى
      // وبكدة انا ظهرت الرساله للuser فى حاله الfailure فى حاله ان الstatuscode كان عبارة عن 400 او 401 او 403
    }else if(statusCode==404){
      // فى حاله ان الrequest not found بالتالى مفيش response راجعلى بالتالى حعمل return 
      return ServerFailure('Your Request  not found ,please try again later  !');
      // ودى معناها ان لو كانت المشكله من الapi المفروض انهم بيحلوا فيها دلوقتى فالمفروض انه لو عمل user try again later تتحل المشكله و

    }
    else if(statusCode==500){
      //فى حاله انه يوجد مشكله فى الserver
      return ServerFailure('Internal Server Problem,please try again later');
      //كدة معناها ان الرساله اللى حتظهر للuser ان يوجد مشكله خاصه بال Server  وحقوله please try later علبان ما ال backend team يكونوا حلوا المشكله
    }
    else {
      return ServerFailure('Opps There was an Error,please try again ');
      // فى حاله ان مش عارف ايه الfailure اللى حصل

    }
// ال factory constructor دة بيعتمد على ال response اكتر ولو مستحدمتش dio error ممكن تستخدم دة على طول
  }
}
  // حستخدم الfactory constructor اللططيف بتاعى وحقوله انا عايز اعمل الserver failure يكون from dioerror وحستقبل بداخله الdio error من نوع  Dio Erro وبعد كدة انا حقوله ان الdioerror اللى بيرجعلك بيبقا ليه type يعنى انت لو جيت هنا وقولت dio error .type حتلاقى انك انت عندك كدا type اساسا لان الtype دة enull بتحمل حاجات كتيرة جدا لو روحت عليه كدة حتلاقى انك عندك اكتر من e null وبما انه e null لو حطيته جوة switch case فالمفروض انه حيظهرلى على طول بمعنى لو انا كتبت switch case وال switch case من افضل الحاجات اللى بتشتغل مع الe null واحط جواها الdio error بتاعى واقوله .type وتلقائيا بمجرد ما احط ال type حيقولك خلى بالك انت المفروض تحط cases بداخل الswitch case وحعمل ctrl +dot واحط الmissing cases فانت هنا عندك اكتر من  type  فى الdio error اللى راجعلك وانواعهم عندك فى الاول فى الcases الخاصه بالdio error عندك
  // انت بتحاول تعمل connectedtimeout  connection : واخدت فترة كبيرة جدا فبالتالى حصل timeout
  // عندك هنا send timeout بتبعت البياناتا اظن وفضل يبعت لفترة كبيرة جدا ومبعتش حاجه فى الاخر فبالتالى حصل time out وممكن تكون مشكله فى الnetwork
  //  عندك هنا recieve timeout بتبعت البيانات  وفضل يستقبل لفترة كبيرة جدا ومبعتش حاجه فى الاخر فبالتالى حصل time out وممكن تكون مشكله فى الnetwork
  //عندك بعد كدة الresponse ودى المهمه لان غيها شغل اضافى يعنى هو رد عليك هنا ب response يعنى هو فى حاله انه هو رجعلك status code بيرجعلك response كمان معاة فهو بيقولك خلى بالك كدة انت راجعلك حاجه يا راجعلك status code يا راجعلك RResponse تقدر تستخدمه وعندك cancel يعنى العمليه اتكنسلت وعندك other يعنى احنا مش عارفين ايه اللى حصل اساسا فالمفروض انى ابتدى واhandle كل واحدة على حدة
  //فى الcooneeecttimeout والحاجات دى ممكن اعمل return مثلا لServerFailure وحاجى اقوله رجعل رساله بتقول ان الConnection Timeout with ApiServer ودة معععناة ان حصل timeout واحنا بنحاول نconnect  على الApiServer واظن ان دى message معبرة فى الحاله دى وحنشيل الbreak لان كدة مبقاش ليها لازمه بما اننا بنعمل return جوة ال switch وحناخد الline تانى ونحطه جوة sendtimeout  ونفس الكلام بس حغير الmessage من connection ل ssend ونفس الكلام فى الrecieve حناخد الmessage دى ونحطها فى الrecieve هنا كدة وحنقوله recieve ولحد هنا الدنيا تمام زى ما انت شايف كدة بدات احس انى ب handle الدنيا بشكل سليم اجى هنا وادخل على جزئيه الresponse فى مرحله الresponse بيرجعلك الstatus code وممكن يرجعلك response لان فى بعض الاوقات ممكن ميرجعلكش response زى مثلا انا عندى ال 400 دة bad request ودة معناة ان فيه مشكله فى الrequest وعندنا 401 دة unAuthorized وددة معناة ان فيه مشكله فى الauthentication اللى بيعملها و 403 دة forbidden ودة حاجه زى ال401 وفى حالله ال404 ممكن يبققى فيه مشكله فى الrequest اللى بتحاول تعمله access فهنا فى الrequest دة فى حاله 404 مش بيرجعلك response اصلا فانت فى حاله ال404 ممكن ميرجعش response والmessage اساسا انت عارفها ان الrequest not found ودة لان 404 اكيد request not found
  // لكن ال400 او 401 او 403 فدول ممكن يرجعولك رسائل نختلفه لكن ال404 دى اكيد not found فبالتالى انا مش محتاج اعمل parse لل response
  // هنا اصلا فانا اللى يهمنى فى حاله الresponse انى اعمل check على  الstatus code بتاعى
  // على اساس الstatus Code دة لو كان 401 او 403 او 400 ساعتها حعمل parse لل response اللى جايلى لكن لو 404 انا مش حعمل parse حرجع message مختلفه شويه وكدة واضح انى حعمل شغل بداخل dioerrortype.response والشغل دة حيبقى على اساس الresponse اللى راجعلى وعلى اساس الstatus code ودة ممكن اعملها factory constructor مختلف ودة بيبقى general اساسا لان دة بيستخدم dio error
  // factory ServerFailure.fromResponse  ودة بيشتغل على ال ودة بيعتمد على الresponse اكتر
  //  لو انت مستخدددمتش dio error ممكن تستخدم دة على طول وهنا حستقبل حاجتين وهما الstatus code وبردة حستقبل الresponse بتاع الdio error فحقول int status code,dynamic response  ,response وممكن تكون جاسون وتستقبل ال<map <String,dynamic ولكن حنسيبها دلوقتى كدة وفى المكان دة انا حعمل check على الstatus code واتاكد انه بيساوى 400 ونفس الكلام المفروض اعمل check على انه بيساوى 401 وبيساوى 403 ودول ال3 حاجات المفروض بيساويهم وفى ال3 حالات دول انا مهتم انى اععمل parse لل response وهنا المفروض اعمل return بقى لserverFailure والserverFailure المفروض انى ححط الmessage على اساس الresponse اللى راجععلى وطبعا عشان دة dynamic فالمفروض انه مش حيرجعلى اى حاجه بس حيقبل اى حاجه تحطها جوة ال message
  //        فتعالى نعتبر ان الresponse اللى راجعلنا هو الmap اللى حنحطها هنا وممكن تخليها<map<String,dynnamic> مش فارقه تعالى هنا بس نخلى الدنيا شغاله بشكل سليم فى الapi وحنشيل الq والq هى الكلمه او الcategory اللى ببحث عنها فى الapi فبالتالى حيرجعلنا error لانه محتاج q لانها required parameter فحيرجعلنا الresponse ب failure وزى ما انت شايف المفروض انك حت access ال error الاول فى المكان دة وبعد الerror حaccess ال message اللى موجودة فى الapi response وطبعا زى ما انت شايف الموضوع بيختلف على اساس response اللى راجعلك وطبعا الموضوع بيختلف على اساس الresponse اللى راجعلك وزى ما قولتلك دى حاجه related اكتر بالapi اللى بتتعامل معاة دلوقتى وانا بحاول اعمل handle لكل الcases اللى اقدر عليها ولكن بردة وارد تحصل مشكله وساعتها بتبتدى تحلها لغايه لما الclass بيبقى فيه شغال معظم الcases وطبعا لما بتيجى بتستخدمه فى تطبيق جديد بتعمل بعض التععديلات فى الresponse لان مش كل response فى الapi,s شبه بعض كدة بالفعل انا حطيت الserverfailure بتاعى فى حاله انه كان ال response 400 او 401او 403 بردة عندى وعندك بعد كدة فى حاله انه الstatus code ب 404 ساعتها حيكون الreqUest not found بالتالى حعمل return ل serverFailure وممكن نقول Method not found وطبعا دى رساله مش معبرة اوى انها تظهر لل user عشان يحلها بس  كدة المفروض انها متظهرش لل user والرساله دى احنا حطينها عشان تظهر لينا احنا يعتبر لان بمجرد ما تظهرلك كdeveloper  عندك 404 فبالتالى حتشوف ايه المشكله عندك فى ال api لان انت حتظهر ايه فى المكان دة غير انت تبعت رساله تظهرلك ان please try again او ممكن اظهرله رساله انplease try later ,  your request is not found  لما ال request يكككون not found ودة معناة ان لما تيجى اللرساله دى من ال APi المفروض انهم الdevelopers عاملين يحلوا فيها دلوقتى بانهم بيجربوا ال api  الصحيح عشان ينفد الrequest بشكل سليم وكدة لما اعمل try later  يقصد يها ان المشكله ساعتها تتحل وشايف كدة رساله معععبرة اعتقد وكدة احنا بنحاول نخلى الشكل يكون جميل  لل user على قد ما نقدر  وبردة لينا احنا بعد كدة حقوله else if  بردة ليه لان ممكن يبقى عندى status code ب 500 ودة معناة انى عندى مشكله فى الserver اصلا فحقول هنا نفس الكلام حقول return ServerFailure("Internal Server error ,please try later "  بحيث انه يبقى عارف انه المفروض يجرب فى وقت تانى بحيث يكون الbackend يكون حل المشكله فى حاله الelse بقى انى مش عارف ايه اللى حصل احنا كدة عملنا check على كل ال status code المهمه مش حقعد اعمل check على كل الstatus code اللى راجعالى دة شىء مش منطقى انا بس بحاول اعمل check على الstatus code اللى ممكن استخدمها وهما 400,401,403 على الاغلب بيبقى فيه response فحستخدم الresponse دة و404 مش حيرجع بresponse لان الrequest اساسا خطا ومش موجود فحبعتله الMEssage اللى انا عايزها و500 نفس الكلام فيه مشكله فى الserver فحعرضله رساله بالمشكله بتاعت الserver بعد كدة حقوله لو مطلعش كل الstatus Codes دى سساعتها اععمل return ServerFailure ساعتها حقوله فى الحاله دى اطهرلى message عبارة عن oops there was An Error please try again طبعا كل اللى احنا حطينه دة كان ممكن يستبدل بال message دى فقط لاغير بس ساعتها كانت حتبقى عبارة عن  مش معبرة المشكله فين message وكدة احنا خلصنا بتاعت الresponse فتعالى بداخل المكان دة وهى الcase  الخخخاصه بالresponse بتاع الdio error وحقوله انىىى عايز اعمل return ل serverFailure لfrom response وحستقبل الstatus code فى الdio error فى الResponse بتاع الdio error وبردة عايز ارجع ال data اللى جوة الresponse لان انا بداخل الresponse انا بتعامل مع الdata اللى هى الmap بتاعتى ودة الللللىىىىىىىىىىىى عايز اعمله وطبعا لازم اكد عليه ان response مش ب null وان الstatus code ايضا مش ب null وطبعا بما انه دخلى فى الserverfailure.fromresponse فخلى بالك ان المفروض يبقى عندى Response وخلى بالك ان محتاج اكد عليه ان الstatus code مش ب null
  // فى حاله الcancel حقوله هاتلى الserverfailure واقوله ابعتلى ان الرساله اللى راجعالى هى request to apiserver was cancelled
  //    server failure فى حاله انه other انا محتاج اعمل chhhheck على نقطه بسيطه بس يعنى تعالى نعمل check على نقطه جوة الdio error . حنجيب الmessage ونقوله contains لان فى حاله الother المفروض على حسب الdocumentation فممكن يكون فيه    socet exception وsocet exception دى معناها ان مش موجود network اصلا فكدة انت عملت request ولا يوجد network فهو رد عليك بال error دة ففى الحاله دى الmessage حتحتوى على الsoCet Exception  وفى المكان بتاع الmessage حتكتب ال message الخاصه بال socet exception لانه حي check على الاسم دة فحقول SocketException وحكتبها زى ما انا كاتبها بالظبط وتعالى نمسح break وطبعا فى الحاله دى انت مفيش network اصلا حعمل return ل SSServer Failure وحقوله يظهرلى message ان no internet connection والموضوع بسيط اى ان مفبش internet اساسا فحبدا اقوله ان لو معملششش return ل ServerFailure حقوله ساعتها اعمل Return لServerFailure يحتوى على message بتقول ان un expected error please try later وكدة احنا عملنا Handle لكل الCases فى حاله الdio error  فى حاله الtimeout فى كل حاجه حتى هنا فى حاله الother شوفنا لو فيها socket exception رجعلنا رساله no internet  connection وطبعا لو مفيهاش حاجه زى كدة زى ال socet exception  وطبعا لو مفيهاش حاجه زى كدة تبقى un expected error لان انا مش عارف ايه المشكله ساعتها try again لانها مشكله مش من الapi ولا مشكله من عندنا ك developers هى مشكله من حاجه مش عارفنها فعلا فعشان كدة بقوله try again فلما يعمل try again ممكن تتحل تمام فاضل الdefault بتاعتنا لان خلى بالك دى switch case ممكن ولا واحدة من دول تحصل فبالتالى يخصل exception فبالتالى نحط الdefaault اساسا وفى حاله الdefault حعمل return ل ServerFailure ونفس الكلام انا مش عارف ايه اللى حصل فحقوله oops there was an error please try again وكدة حرفيا انا بعمل handle لكل حاجه يعنى انت عندك هنا بتعمل handle لكل cases فى server failure  فانت هنا عندك ال
  // كدة انا حرفيا بhandle كل حاجه يعنى انا عندى الserver failure بتHandle فيه كل حاجه فعلا كل الcases زى ما انت شايف طبعا ممكن لما نيحى نعمل run للتطبيق وكدة نقابل حاجه غريبه بس اعتقد صعب  اعتقد صعب فعلا لاننا عاملين handle لكل حاجه فعلا فممكن نروح على الhome repo implementation ونشوف لما نيجى نعمل run للكود هل حنقابل مشكله فعلا احنا مش متوقعنها ولا لا لو قابلنا مشكله نبتدى نعدل ونعمل تعديلات ودى عمليه طبيعى نمشى عليها وانا زى ما قولتلك انا بكتب الكود معاك لاول مرة فبالتالى ممكن يبقى معاك بعض الاخطاء وحنلاحظها واحنا بنعمل rrun فحروح على الhome repo implememtation واقوله فى الreturn الخاص بال left side لو انا عندى serverfailure وكان الfailure فى الحاله دى from dio error ساعتها حبعتله الdio error بتاعى وحتلاقى ان الدنيا clean جدا وانت ممكن تستخدم الfailure class دة فى اى project اخر حتاخدة وتحطه فى اى مكان تانى وخلص الموضوع على كدة مش حتقعد تكتب الكود دة تانى تمام كدة فاحنا بدينا نستخدم الserverfailure.fromDioError عشان نقدر نhandle كل حاجه ليها علاقه بالDio Error لكن طبعا احنا هنا بنعمل catch لل exception بشكل عام طب لو الexception اللى جايلى مش dio error ممكن يكون مشكله فى parsing ساعتها حغمل return مختلفه يعنى انت عامل if condition فى حاله ان الexception كان dio error ساعتها اعمل return لحاجه معينه وخلاص على كدة لو كان الerror عبارة عن exceptiion مختلف عن الdio error exception ساعتها حقوله return  ل ServerFailure وابتدى اااحط الmessage بتاعتى فانا هنا ممكن اقوله e,toString() واحنا كدة خلصنا عمليه ال handle بتاعت الexceptions سواء dio error او سواء اى exception تانى// فى حاله اى exception تانى حولى toString اى حولى اى exception ل string وخلاص لان هو بيبقى سايف كلمه exception وجمبها message بتاعتك دة لو فيها رساله وبعض الاوقات مش بيكون فيها message فانت كدة عملت الrequest وحتعيد استخدامه فى كل الاماكن التانيه وشكل الrequest بصراحه كويس وclean كدة وكدة احنا عملنا create ServerFailure from dio error
// كنا المرة اللى فاتت استخدمنا الserverfailure عشان نضيف فيه الfrom dio error constructor تمام عشان نhandle ال error اللى بيجيلنا المفروض انى حعمل implement لتانى method موجودة عندى لان بالمرة بما انى شغال فى الrepo فكدة كدة اخلص جزئيه الdata layer بالمرة مرة واحدة وبعد كدة اروح على الاجزاء الباقيه تمام فالfetchFeatured Books method دى ب fetch فيها الfeatured books فانا هنا حشغل نقطه انى اخد الcopy patse بقى يعنى بما انى كاتب الكود دة قبل كدة ممكن اخدة copy واعدل فيه النقط اللى انا عايزها خصوصا انى كل اللى حعدله هى الجزئيه اللى جوة الtry لكن الباقى كله واحد تمام فحخلى الmethod تكون async كدة وزى ما انت شايف كل حاجه اتحلت على طول بس طبعا حغير فى الrequest دة بما اننا كدة كدة بحصل على نفس الdata اللى موجودة بداخل الbook model فتقريبا مش حغير خالص اى حاجه فى المكان دة لكن طبعا لو ب fetch حاجه مختلفه فانت بس حتغير فى المكان دة اللى هو الfor loop بس لكن الrequest وكل حاجه زى ما هى فانا هنا جووة الfeatured books انا ب fetch الfeatured books معناها انى حfetch ال books انا عايزاها featured ودى حاجه ترجعلى دلوقتى انا كdeveloper فانا دلوقتى طبعا مهتم بموضوع الprogramming لكن مش عايز الnewest يعنى انا ممكن امسح بس الsorting اللى انا حاطه دة لانى عايز اجيب الprogramming بشكل عام لكن مش newest والكلام دة دة دة دة دة دة دة دة دة لا انا عايز الbooks كلها اللى ليها علاقه بالprogrmming لانى عايز اجيب كل الكتب بشكل عام لكن مش عايز يبقى جزء من الكتب على حسب newest عشان كدة حخلى الrequest يكون نفس الreqquest اللى فوق لكن الاختلاف الوحيد انى حشيل الsorting الاضافيه اللى هنا لكن الباقى زى ما هو فزى ما انت شايف احنا كدة عملنا implementation لل method اللى قدامنا دى وبكدة نكون عملنا جزئيه الhome repo وبكدة يكون الجزء دة انتهى
//   اهلا بكم يا شباب كنا المرة اللى فاتت انتهينا من الhome_repo وعملنا implementation لل methods اللى موجودة فى الhomerepo دلوقتى احنا حنبدا وندخل فى جزئيه تانيه وكدة انا انتهيت من الdata layer بتاعتى بانى انشات الmodels وكمان عملت home repo وال home repo implementation وكدة انا خلصت جزئيه الdata layer الجزئيه التانيه انى ابدا اربط بين الdatalayer وال ui بتاعى وهنا انا حابب اتكلم فى نقطه نظرى يعنى فى المحاضرة دى انا مش حكتب كود خالص لكن حنتكلم كلام نظرى شويه احنا دلوقتى بنستخدم architecture ايه فى التطبيق دة انا هنا بشتغل على mvvm pattern وبتكون متقسمه لmodel اللى هو الdata layer و view modelوبعدين الview والview بتمثل جزء من الpresentation layer وعندك بعد كدة الview model ودة اللى بيعمل manage لل state بتاعت الview يعنى دة اللى بيتحكم فى انه حيعرض ايه فى الui والكلام دة اى انه بي manage ال state بتاعتها وطبعا دة بيقكر بحاجه تانيه وهى ال bloc والbloc architecture نقس النظام كدة  بالظبط بتقسملك الكود بتاعك بتخلى الlogic بتاعك فى حته والui بتاعك فى حته والbloc دات نفسه بيmanage ال state عشان كدة تقدر تقول الmvvm وال bloc الاتنين زى بعض بالظيط يعنى انا جوة الpresentation layer مثلا ممكن احط new folder واسميه مثلا view  model او manager وخلى بالك دة كدة صح لان انت كدة ماشى على الmvvm pattern وال view model ممكن يبقى provider لو انت بتستخدم provider وممكن يكون getx controller لو انت بتسخدم provider وممكن يكون bloc لو انت بتستخدم bloc ممكن يكون اى حاجه لان الview model هنا بيعير عن حاجه ب manage بيها الui بتاعى بmanage بيها الstates بتاعت الui بتاعى عشان كدة بقولك ان مفيش فؤق بين ال bloc وال mvvm لان ال bloc ييؤدىىى نفس الغرض فانت مجير على ال bloc انت مجبر على الbloc انت بتستخدم الbloc فاكيد حستخدم الbloc ك state management لكن الmvvm انت متاحلك تستخدم اى حاجه فى المكان دة اللى هو بداخل الmvvm انت متاحلك تستخدم الgetx او الprovider او ال bloc بداخل الview model قبالتالى فى المكان دة اللى هو الfile الخاص بال view model ممكن اخليه باسم manager لان انا ممكن احط اى state management بداخلها سواء getx او provider او لbloc وكدة انت ماشى على architecture تققدر تسميها الmvvm لو انت بتستخدم الbloc فانت تقدر تسميها انك ماشى على bloc كدة انت ماشى على architecture فى كل الاحوال اى حاجه حتستخدمها حتحطها هنا لو حطيت cubit يبقى انت بتستخدم architecture لو انت حطيت provider يبقى انت بتستخدم architecture يعنى لو حطيت provider يبقى انت الarchitecture اللى انت بتسخدمها اسمها الmvvm ولو حطيت bloc فالarchitecture اللى انت بتستخدمها هى الmvvm بس عشان استخدمت الbloc بدلا من الview model فنقدر نقول عليها الbloc architecture لان الاتنين واحد وهو اختلاف مسميات انا مش عايزك تتلخبط فى الموضوع دة فانا حاجى فى المكان دة جوة الmanager وابتدى انشا الcubits اللى  اقدر اعمل handle بيها  لل ui بتاعى ودة اللى حبتدى اعمله ان شاء الله من المرة اللى جايه فانا بس عايزك تفهم ان الmvvm والbloc الاتنين يعتبروا واحد فى حاله انك استخدمت ال bloc عشان متحسش مثلا ان الmvvm دة architecture مختلفه ولازم اتعلمها وان الbloc دى architecture مختلفه ولازم اتعلمها لا خالص الاتنين واحد اصلا لان الmvvm هى هى الbloc architecture الفرق انك انت ممكن بدلا من الview model تقدر تستخدم اى  statemanagement لكن الbloc architecture فيه حاجه محددة حتحطها وهى الbloc بتاعك ودة الفرق بين الاتنين والفرق تافه ميعتبرش فيه فرق اصلا
//     اتكلمنا عن الفرق بين الmvvm وال bloc architecture وعرفنا ان الاتنين يعتبروا شىء واحد لو بتستخدم الcubit ك statemanagement او الbloc ك statemanagement تمام فطبعا النهاردة المفروض حبتدى وانشا الcubits عشان تhandle ال state بتاعتى فطبعا لو جينا هنا نبص على الhome feature بتاعتنا حتلافى اننا كدة خلصنا الdata layer وحتلاقى عندنا الpresentation layer احنا خلصنا جزء الui فاصل اننا نبدا نشتغل فى الmanager عشان نhandle ال states بتاعت الui او نعمل handle لل ui بشكل عام زى اننا نعرض البيانات ونشوف هو بيload اال data ولا لا والكلام دة فطبعا لو روحت على الhome view اصلا من غير حتى ما ابص على الdesign بيظهروا عندى فى الhome view وهما ال list الخاصه بال featured books وعندى list فيها الbest seller books بتاعتى طبعا ممكن نغير الاسم بتاع الbest seller books لان احنا خليناها newest بس حنغيرها بعدين مش دلوقتى فدلوقتى انا عندى حاجتين بيتعرضوا هنا فقدامى خيارين وهو اما انشا cubit واحد يعمل handle للاتنين او انى انشا cubit ي handle كل واحدة لعلى حدة من ال2 lists فالاصح هنا انى انشا cubit مخصص لكل حاجه ودة لانى عندى مبدا فى البرمجه يسمى single responsibility principle ودة فى الsolid principles بتاعتك والمبدا دة بيقولك ان اى class او اى method بتعمل حاجه واحدة فقط لا غير مينفعش تعمل حاجتين يعنى انت ممكن تطبق الكلام دة هنا انا عندى الcubit المفروض انه يشتغل على list واحدة ويجيب الfeatured books وهو حيجيب الfeatured books وخلص الموضوع على كدة مش محتاج اخليه يعمل حاجه تانيه طبعا فى بعض الاوقات ممكن يعمل حاجات تانيه بس related لنفس النقطه مش حاجه مختلقه خالص يعنى انا هنا بعمل fetch لل featured books وهنا بعمل fetch لل best seller books ودول حاجتين مختلفتين عشان كدة ممكن انشا  2 cubits مختلفين بدل ما انشا cubit واحد ي handle الموضوع دة وكمان بردة لو حبيت تنشا cubit واحد لل2 lists  فحتلاحظ انك لازم تنشا states مختلفه ودة لان مثلا دة ممكن يكون لسه بي load ال data فى list والتانيه success او مثلا الاولى fail والتانيه success فبالتالى انت عندك states مختلفه اصلا فبالتالى حتضطر تنشا states مختلفه عشان تقدر تhandle الموضوع بشكل سليم وحتنشا 2 methods لكل واحدة فيهم فكدة بالتالى انت كدة يعتبر كانك انشات 2 cubits اصلا فبالتالى افضل حال انى انشا cubit مخصص لكل حاجه ودايما خليها دى القاعدة بتاعتك وعندك cubit مخصص لكل نقطه بدات احس ان الcubit عمل handle لlist  التانيه دى لانها related بالlist  اللى انا شغال عليها ماشى مفيش مشكله ودى حتستوعبها اكتر وانت شغال تمام فطبعا دلوقتى حروح للmanager بتاعى وابتدى انشا اول cubit ففى البدايه حضيف flutter_bloc بالشكل دة وكدة هو حيضيف ال package تعالى بقى نروح على المكان دة كدة وجوة الmanager حبتدى وانشا اول cubit عندى فانا دلوقتى حhandle االfeatured books وبالتالى حنشا لل featured books cubit,state وحخلى اسم الfile الخاص بالcubit الخاص بال featured books cubit بالمنظر دة وهنا حروح على الstates وابتدى واحدد الstates بتاعتى وطبعا انى احدد الstates الخاصه بالmethod دة امرها سهل وطبعا الموضوع بيعتمد اكتر على انك بتhandle ال states بتاعت ايه لكن على الاغلب لو انت بت handle data من على النت فانت بيبقى عندك 3 states واحد ان state بتقولك انك بتعمل load لل data دلوقتى وstate بتقولك انك خلاص اتسلمت الdata بشكل سليم وstate بتقولك حصل مشكله عندك وانت بت load ال data فعلى الاغلب بيكون عندك 3 states اساسيين وهما loading ,success,failure وطبعا دلوقتى دايما الfailure حيشيل الerror message بتاعته عشان يعرضها فحعرف متغير يسمى errormessage واحطها جوة الconstructor بتاعى وطبعا خلى الconstructor يبقى const وبعد كدة الsuccess وفى الsuccess حيكون قدامى اختيارين وهما انى اخلى الdata اللى جاتلى بالفعل عايشه فى الcubit دات نفسه او تجيلى من خلال الstate بتاعت الsuccess فانا بختار على اساس انا بعرض البيانات فين وهى انا لو حعرض البيانات جوة list حديها للlist على طول فخلاص حستقبلها فى الsuccess فانا هنا يا شباب بعتمد على نقطه انى حعرض البيانات فين وعلى اساسها بحدد هل انا حستقبل البيانات جوة ال success state ولا حخليها جوة ال cubit يعنى  انا دلوقتى مثلا لو انا حعرض البيانات جوة list فعلى طول خلاص انا جوة ال list يدوب حاخد البيانات من ال success state وحبعتها للlist على طول وخلص الموضوع على كدة لكن ولنفترض ان دلوقتى عندى الدنيا متشعبه شويه عندى مثلا مجموعه widgets كتيرة جدا فانا محتاج ابعت لكل widget من دول البيانات اللى جايالى من الsuccess state فطبعا كدة حضطر انشا كش شويه متغير واحط متغير فى ال constructor وهكدا فالموضوع بيبقى ممل طبعا فانا بخليها جوة ال cubit على طول ولو حبيت اaccess بaccessها من خلال الcubit وطبعا بما انى هنا بتعامل مع list فافضل مكان احط فيه البيانات جوة الsuccess state فحنشا متغير واقوله <final List<BookModel> واسمى الbooks list ب books مثلا وطبعا انشاءلها الconstructor بتاعها واحط const وزى ما انت شايف انا كدة انشات الstates بتاعتى وكدة انا انشات الstates الخاص بالfeatured books cubit states
//     المرة اللى فاتت كنا انتهينا من انشاء الcubit بتاع الfeatured books وانشانا فيه الstates بس مش اكتر النهاردة المفروض حنبتدى ونكمل وننشا عندنا الmethod اللى جوة الcubit واول حاجه هنا يا شباب انى ححط الrepo بتاعتى اللى هى الhome repo واسمى المتغير home repo  بداخل ال cubit  وبعد كدة استقبلها فى الconstructor الخاص بالcubit ودى اول حاجه لانى حستخدمها عشان استدعى الmethods بتاعتى وبعد كدة تعالى انشا method حخليها future void عشان تبقى ادق لانها بالفعل فيها شغل future والmethod دى بتfetch الfeaturedBooks طب بتاخد arguments لا مش بتاخد اى حاجه  خالص فحبتدى هنا واستخدم الhome repo بتاعتى طبعا فى البدايه خالص حعمل emit لل loading state ودة لانها هى حاله initial state الخاصه بالfeatured books وبعد كدة حستخدم الhome repo بتاعتى وحقوله fetchFeaturedBooks وطبعا انت عارف انها async  وحخليها async عشان استخدم ال await وحقول هنا الresult وهى الvar result والresult حتبقى عبارة عن either object زى ما انت شايف بيرجعلك either اساسا فانت لو جيت تستخدم الresult كدة حتلاقى ان الresult بيوفرلك method  لطيفه جدا اسمها fold وfold دى بتديلك حاجتين اى 2 methods method بترجعلك فيها الfailure object اللى راجعلك وmethod بترجعلك ال success object اللى راجعلك طبعا فى الحاله دى احب اخلى الاسم يكون واضح بلاش يكون l ,r فهنا حوضحلوا ان هنا بيرجعلك الfailure وال method دى بيرجعلك الobject success اى ال books فاظن كدة ان الدنيا حتبقى واضحه لشخص حتى لو حيقرا الكود وهو مش عارف ايه اللى بيحصل فى المكان دة لان هو لاحظ انه ممكن يقف على الfold ويفهم هو بيعمل ايه وغير كدة لاحظ ان فيه failure object وان حيحصل emit لstate وهنا فيه books واحصل emit ل State فالمفروض يستنتج الدنيا ماشيه ازاى بعنى اعتقد الموضوع مش حيكون معقد جدا طبعا انا بحب احط cearly pracist عشان لو حكتب كود او حاجه زى ككدة وفى الحاله دى كل اللى انا حعمله انى حعمل emit ل failure state هى featuredbooksFailure  وابعت بس الfailure.errMessage ودة عشان انا متاكد بالفعل انه يختوى على error message ودة لانى انا  انشات الfailure لو تفتكر انشاناا وحطيناة جواة string errormessage وعندنا كمان فى حاله الsuccess انى حعمل emit featuredbookssucess وابعتله الbooks وخلص الموضوع على كدة وزى ما انت شايف الدنيا شكلها لطيف جدا وزى ما انت شايف دة منظر الكود عندى منظر الكود جميل جدا الكود بسيط مفيهوش try &catch ودة لانى عامل handle للدنيا بشكل سليم ودى طبعا الhome repo اساسا وزى ما انت شايف الموضوع بسيط جدا وماخدش منى ثوانى لانى بالفعل عملت handle للحاجات الصعبه اللى هى الrequest والحاجات دى هنا انا مجرد بhandle بس الstates بتاعت الui يعنى انا هنا مش بجيب data لا انا بستخدم الdata اللى جايالى عشان اعمل handle ال states بتاعت ال ui وكدة احنا عملنا create للfutured bookscubit  methood الخاصه بال cubit الخاص بالfeaturedbookscubit
//     كنا المرة اللى فاتت انتهينا من انشاء الmethod جوة الfeaturedbook cubit طبعا الموضوع مخدش مننا وقت وكان بسيط جدا    لان احنا بالفعل عملنا الاجزاء الصعبه جوة الhome repo وكل اللى احنا عملناة هنا اننا استدعينا الmethod وبدانا على اساسها نmanage ال state بتاعت الui النهاردة المفروص حنبتدى ونبنى الcubit التانى عندنا يعنى انا دلوقتى المفروض اننا بنينا الfeatured bookscubit فانا دلوقتى حنشا cubit مخصص للnewest books فحروح جوة الmanager وانشا cubit جديد وحسميه newest books وجواة حنشا newestbooks_states.dart ححط فيه الstates الخاصه بال newest books  وهما ال loading ,success , failuure ودول ال 3 states المهمين وطبعا فى  حاله الfailure عندى final string errorMessage وحنستقبله فى الconstructor وححط const بالمرة ونفس الكلام فى الsuccess انا عارف انه حيجيلى <list <BookModel> وحسميها books وحستقبلها بردة فى الconstructor ونفس الكلام const وكدة خلاص خلصنا الstates زى ما انت شايف الموضوع بسيط وكدة نبقى احنا عملنا create newest_ books_ cubit_ states وحنشا file يسمى newest books_cubit ودة خاص بال methods اللى حستخدمها فى الhome repo فحاخد نفس الmethod الخاصه بال fetchfeaturedbooks بس حغير اسم الmethod ل newest books وحعمل emit ل states الخاصه بال newest states وشايف الدنيا لطيفه ازاى معاك وانت شغال تحس الدنيا جميله كدة والاكواد واضحه انا عارف الخطوات اللى ماشى عليها والدنيا مش صعبه خالص بدانا ننشا الcubit بتاعتنا والامر بسيط انا مش شايف ان فيه صعوبه خالص فى اننا نعمل الكلام اللى قدامنا دة فلحد دلوقتى احنا ماشيين بشكل ممتاز جدا فى التطبيقات الصغيرة والمتوسطه وتقريبا حيمشى معاك فى كل المشاريع اللى حتقابلك لغايه لما تبتدى تشتغل على مشاريع ضخمه فعلا مش مجرد اسم لا ضخمه فعلا محتاجه تيم كامل مش فرد او اتنين يشتغلوا عليه ومتنساش تغير اسم الmethod بما انك اخدتها copy من fetchfeaturedbooks للfetchnewestbooks وبكدة نكون خلصنا الnewest  books cubit
//                     هاصلاهلا بكم يا شباب كنا المرة اللى فاتت انتهينا من انشاء newest books cubit زى ما انت شايف النهاردة بقى المفروض حنكمل النقط اللى نلى دى بس حابب اتكلم عن نقطه ان احنا كدة خلاص خلصنا الدور الرئيسى بتاعنا يعنى انا دلوقتى ابتديت بالفعل بالdata layer خلصت الاجزاء بتاعتى وفى الpresentation layer انشاءت الcubits فى الview models او الmanager لو بستخدم bloc architecture ولحد هنا دة المهم يعنى احنا كدة بنينا الui وبنينا الlogic خلاص خلصنا الجزئيين دول بشكل منفصل دلوقتى فاضل انى ابتدى واعمل integration ما بين الui وال logic بتاعى فهنا فيه بعض النقط اللى حنتكلم فيها بس اللى يهمنى ان احنا كدة خلصنا الاساس يعنى احنا بالفعل فى الجزئيه دى خلصنا الاساس بتاعنا اللى هى الarchitecture اللى المفروض تمشى عليه بدايه من الdata layer وانشاء ال models وانشاء repo بتاعتك بعد كدة انشاء الimplementation لحد لما تطلع على انشاء الcubits بتاعتك تمام وزى ما انت شايف الموضوع مش صعب نهائى الموضوع بسيط جدا وخطوات صغيرة لكن فعلا بتفرق بشكل الكود بتاعك يعنى اظن لو كتبته بالاسلوب دة فعلى الاقل الكود بتاعك حيكون مكتوب ب architecture نظيفه وسهل انك تكبر الarchitecture فبالتالى سهل جدا انى احول من الmvvm ل clean architecture حيبقى الموضوع بسيط جدا او لاى architecture تانيه فالموضوع بسيط جدا الى ان لو انت اكتفيت بال mvvm architecture فمفيش مشكله لان الكود بتاعك مكتوب بشكل كويس الى جانب اننا كتبينا الui بتاعنا بشكل كويس جدا لان خلى بالك الجزئيتين مهمين جدا انا بشوف بعد الاشخاص انهم يكتبوا الlogic كويس جدا والاقيهم كتبين ال ui بشكل سىء جدا سىء جدا فعلا فطبعا دة بيقصر على اللتطبيق او كاتبين ال ui بشكل كويس لكن مش جايبين نفس ال design فطبعا دة بياثر غلى التطبيق احنا معندناش مصطلح ال front end وال back end احنا معندناش المصطلح دة دة مش موجود عندنا احنا مطورين تطبيقات موبايل الموبايل كله التطبيق بالكامل احنا بنطورة مفيش حاجه اسمها اشتغل فى الlogic ومش اشتغل فى الfront اللى هو الui عندنا معندناش المصطلح دة فمتخليش حد يقولك انت ممكن تركز فى حاجه منهم وتسي التانيه لا مفيش حاجه اسمها كدة مطور تطبيقات الموبايل لازم يكون كويس فى النقطتين فدى نقطه لازم تحطها فى دماغك عشان بشوف ناس كتير بتسيبها عشان كدة انا استهلكت وقت فى بناء ال ui لان دة كان شىء يهمنى جدا زى ما يهمنى تفهم جزئيه  data وال presentation والكلام دة وتمام كدة خلاص خلصنا جزئيه ال cubits بتاعتنا فدلوقتى ممكن بالفعل استخدمها فى بناء الui فتعالى نروح على الpresentation layer حنروح على الviews حتلاقى انك عندك 2 views فحروح على الhome view بتاعتى فانا فى الhome view المفرةض انى حستخدم الcubit فى المكانين هنا عندى حستخدم cubit فى الFeatured books  وهنا حستخدم cubit فى الnewest فقبل ما ابتدى واستخدم ال cubit انا محتاج اعمله عمليه provide يعنى انا محتاج اوفر الcubit للشاشه بتاعتى فانت المفروض عارف انك المفروض عشان توفر الcubit فانت المفروض بتستخدم حاجه اسمها ال bloc provider يعنى لو انا روحت دلوقتى على الmain .dart وقولتله  انى ححط ال material app جوة ال multiblocprovider ودة بيسمحلنا نوفر اكتر من bloc او اكتر من cubit عن طريق انى استخدم فى الproviders بتاعت الmulti bloc provider bloc provider خاص بيا والcreate بتاعتى حتكون عبارة عن context ويعد كدة حترجعلى الfeatured books cubit وركز فى النقطه دى بعد كدة عندى الhomerepoimplementation ومينفعش اختار الhome__repo لان الhome repo بتحتوى فقط على تفاصيل اللى حيحصل فى الimplementation بتاعى مش بتحتوى على الimplementation خالص فبالتالى مينفعش استخدمها بداخل الfeaturedbookscubit فخستخدم الhome repo implementation محتاج ابعتلها الapi service بتاعتى بعد كدة ححتاج ابعتلها الdio service يتاعتى ولازم ابعت نسخه من الdio هنا دلوقتى حنتكلم عن المنظر دة  يعنى فالمنظر دة طبيعى لان كدة انا بنشا cubit فطبعا الcubit اساسا بيستقبل home repo implementation بتستقبل api service لانها بتستخدمه والapi service بيستقبل Dio لانه بيستخدم dio فانت هنا عندك اكتر من حاجه عمال تحطها فى الconstructor مش شىء غلط لكن بردة انا شايفه مش ششى ء ضح ليه بردة تعالى اوريك  انا دلوقتى  عايز انشا بردة newest books cubit فحاخد نسخه من الbloc provider واحطها فى المكان الخاص بالproviders فانا كدة اصبحت بوفر 2 cubits طبعا تعالى نغير الاسم كدة وهو newest books cubit وزى ما انت شايف انت كدة بقيت بتوفر 2 cubits الموضوع مش غلط الموضوع صح وحطيمه بالفعل جوة multi bloc provider لكن هل دة الاصح اى هل دة اصح حاجه ؟ وليه بسال السؤال دة ؟ لان انا لاحظت اننا عندى الhome repo implementation متكررة وطبعا ال api service متكررة والdio متكررة وهنا فيه اكتر من حاجه انا حطيتها فى الconstructor متكررة معايا وطبعا وارد جدا ان انت يبقى عندك ال home repo implementation   ببقىىى فيها اربعه او خمسه methods فبالتالى الشكل دة حيتكرر معاك اربع او خمس مرات فكتير جدا فانا هنا يا شباب حابب اتكلم عن مشكلتين انا شايفهم فى المكان دة عشان نبتدى نفكر ازاى نحل المشكلتين دول المشكله الاولى  هو انى عندى اكتر من instance بيتعمل منها نسخه وانا مش محتاج حرفيا اكتر من نسخه يعنى مثلا الhome repo implementation اتعامل منها نسخه فى ال featured books cubit واتعمل منها نسخه فى الnewest books cubit وفى الapi service ايضا وايضا الdio اتعمل نسخه ونسخه ونسخ مستقله عن بعض يعنى نسخه ال home repo implementation اللى فوق غير نسخه ال home repo implementation اللى تحت دةobject ودة object مختلف على الرغم ان الاتنين بيحتوا على نفس الحاجه بالظبط طب ليه معملتش نسخه واحدة ووفرتها للاتنين يعنى دى نقطه جت فى دماغى ونفس الكلام حيبقى معمول فى الapi service ونفس الكلام حيبقى معمول فى الdio والنقطه التانيه هو الااعتماد على الfeatured books cubit على الhome repo implementation يعنى حاليا دلوقتى الfeatured books cubit بيستخدم الاجزاء دول يعنى بيعتمد عليهم فبالتالى اى تعديل يا شباب حيحصل فى اى مكان زى انى اروح على الapi service واخليها تستقبل حاجه غير الdio مثلا فلنفترض قررنا انها تستقبل http او تستقبل حاجه زيادة فبالتالى حضطر اروح فى كل الاماكن اللى بتستخدم ال class api service عشان اعدل فيها النقطه دى لان دلوقتى api service بقت بتستقبل حاجه جديدة زى مثلا انى عرفت متغير وليكن x نوعه int بداخل الapi service واستقبلته فى constructor قبالتالى حلاقى ان كل الاماكن اللى بستعمل فيها الapi server بتدينى error ودة لانها بتعتمد على عنصرين وهما الdio وال x فبالتالى اى تغيير حيصحصل فيها لازم حيقصر عليا ودة شى ء مش كويس لكن يفضل اننا نخلى الحاجات مش معتمدة على بعض بشكل قوى تمام فعايزين نحل المشكله دى وهنا ندخل فى مبدا يسمى dependency injection ودة يحللنا المشاكل اللى اتكلمت عنها دلوقتى فانت خليك مدرك اننا حنستخدم الconcept دة اللى هو الdependency injection غشان نحل المشكلتين دول بس مش اكتر متصعبش الدنيا على نفسك خالص انا هنا وضحتلك مشكلتين واظن وضحت جدا فى المكان دة المشكلتين واضحين وليهم حل يندرج تحت الconcept دة طب نحله ازاى باستخدام فلاتر خلى بالك ان الconcept دة موجود فى كل حاجه موجود فى اماكن كتير جدا مش عندك انت بس فالسرا دلوقتى ازاى نحله فى فلاتر على طول طبعا انت ممكن تحله بكود direct على طول من غير ما تستخدم الpackage اللى انا حستخدمها دلوقتى وفيه اكتر من طريفه عشان تحل المشكله دى لكن انا حستخدم package مشهورة جدا تعالى بقى عشان نروح عليها وهى get it flutter ودة اللى انا كتبته على google chrome عشان تظهرلنا ودى اول package ظهرتلنا وخلى بالك دى package of the week ل flutter team وممكن تتفرج على الفيديو هو فيديو بسيط جدا عبارة عن دقيقه وساعتها حتبدا تستخدم الpackage دى اصلا وهو فيديو بسيط وجميل يعنى فانت ممكن تشوفوا ال package دى يا شباب كل الهدف منها انها بتنشا single ton pattern ودة بنستخدمه كتير جدا فى الshared preference والpattern دة مهمته هى ان بدلا من انك تنشا نسخه من حاجه معينه تنشا نسخه معينه مرة واحدة وتعيد استخدامها ودة مفهوم الsingleton فهنا نفس الكلام get it بتعتمد على الموضوع دة انها service locator بمعنى انها بتنشا service وبعد كدة بت locate ال service دى وتعيد استخدامها بدل ما كل شويه تستخدمها طبعا احنا كدة كدة حنطبقها للتوضيح وعايزك تركز على نقطه هنا بيقولك انك ممكن تستخدم ال service locator اللى هو الget it بدلا من ال inherited widget او الprovider عشان تعمل access ل object ودة الهدف منها اساسا يعنى وطبعا هو استخدامها سهل جدا يعنى مش حعانى غشان نستخدمها وخلى بالك فيه بعض الحاجات اللى حتعمل generate كمان للكود دة بس صراحه مش مستاهله الموضوع بسيط وابسط من انك تgenerate الموضوع دة فتعالى اوريك ازاى حنستخدمها اول حاجه انا بحب انى انشا file بيحتوى على الكلام دة كله يعنى انا حروح على الlib folder واروح على الcore وجوة ال utils حنشا file يسمى servicelocator والهدف منه انه ي locate اى يحدد اى service انا عايزها بعد كدة جوة ال class دة اللى هو ال service locator حمشى على نفس الخطوات اللى موجودة عندى فى الpackage فهو اول حاجه بيقولى عليها هى انشاء نسخه تسمى get_it.instance وحعمل نفس اللى قايلى عليه بالظبط ومش حعمل اى حاجه زيادة وتعالى طبعا نعمل import لل package بس حضيفها فى الاول get it وبداخل الservice locator انت انشات نسخه مش اكتر تعالى بقى نعمل setup method جوة المكان دة بعد كدة هو انشاmethod تسمى setup وجوة الmethod دى المفروض انه بينشا الsingletons بتاعته او الservices بتاعته اللى هو محتاجها لما يختاجها بيستدعيها على طول بدل ما كل شويه يبتدى ويعمل منها نسخه ومبيفكركش بحاجه الكلام دة بيفكرك طبعا بالجزئيه اللى احنا قابلناها فى الmain .dart لان الmain .dart لو تلاحظ عندى services اهى كل شويه عمال باخدها وانشا منها نسخه  طب ما انا لو كان ينفع كنت انشاها فى مكان واحد وبعد كدة اعمل locate لل service واستدعيها فهى هى مش كل شويه بنشا نسخه منها لا فبالتالى الموضوع دة كان حيبقى افضل بكتير فعشان كدة حنعمل الكلام دة هنا فطبعا حعمل import فى الserver locator لل get it الاول وكدة احنا خلاص انشانا instance من الget it دلوفتى انشا method اسمها setup جوة الmethod دى فيهها الحاجات اللى هو عايز يحطها وهى ال services اللى هو مهتم بيها فطبعا الكود دة حيختلف عن الكود اللى احنا حنكتبه بس تعالى ننشا نفس ال method فخروح وانشا method نوعها void تسمى setup وجوة ال setup حبتدى وانشا services وال services دى حابين نستخدمها لما نحتاجها وال services اللى انا حابب انشاها دلوقتى هى الhome repo implementation لان واضح انى بنشاها كل شويه فليه منشاءش واحدة منها واستدعيها على طول بدل ما كل شويه استدعيها وبعد كدة حاجى فى الsetup method واستخدم get it اللى هى الinstance اللى انا عملتها عشان اعمل حاجه اسمها register ل singleton وregister singleton دى واضح من اسمها انى بنشا singleton والموضوع بالبساطه دى فانت عارف ان فيه patternاسمه singleton pattern والمفروض انه له خطوات عشان اعملها ممكن انت بالفعا تعملها مع نفسك بس الpackage بتسهلك الموضوع ممكن انك انت تعمل single ton دى على طول تمام بعد كدة حتلاقيه بيقولك انك بتحدد اسم الحاجه اللى حتتحط جوة الobject او الservice اللى انت عايز تنادى عليها فانا دلوقتى عارف انى انا  عايز احط جوة الregister singleton ححط الhome repo implementation فحقوله باخل المكان اللى هو الsingleton register عايز احط ال  home repo implementation وبعد كدة هنا حتيجى وتنشا ال
//     وبعد كدة هنا حنشا ال instance بتاعتك اى ان هنا حنشا ال home repo implementation يعنى ممكن اخد الكود دة ةاخدة copy واحطه فى المكان دة ctrl +v وحعمل  import لل apiservice مثلا ونعمل import لل dio فدلوقتى احنا انشانا حاجه اسمها singleton لل home repo implementation فانا دلوقتى بقى كل اللى محتاج اعمله انى استخدم ال single ton دى بدلا من انى اعمل نسخه من ال home repo implementation فى كل حاجه موجودة جواها كل حاجه موجودة جواها تمام مش محتاج اعمل حاجه زى كدة خلاص الى جانب ان لو حصل تغيير فى الapi service حيسمع معايا فى المكان دة بس اللى هو جوة الsingleton  فبالتالى التعديل اللى اعمله هنا  دة حيسمع معايا فى كل حته طب كمان شويه ممكن يظهر معايا home repo مختلفه فلنفترض مثلا انى انشات class اسمه auth repoوعايز احطها ك single ton فساعتها حناخد الكود بتاع create ال single ton واضافه الservice اللى عايزها اناديها مرة واحدة فى الapp بحيث انى اعملها تعديل يسمع معايا فى كل ال app مرة واحدة وححط الservice اللى عايز اضيفها من خلال الauth repo وطبعا هو حيضطر امسح كل حاجه موجودة هنا وطبعا حضطر امسح ال api service وال dio بس تعالى نضيف ال api service بداخل ال auth repo بانى حنشا متغير  يسمى الapi service جواها بردة
// واعملها import فى الconstructor فكدة حتشتغل معايا بشكل سليم طبعا دلوقتى عملنا single ton بالفعل  وحلينا المشكله يعنى الauth repo دى لو نفترض حد حيستخدم الauth repo فخلاص الدنيا حتبقى ماشيه معاة بشكل سليم وعندى نسخه واحدة موجودة هنا لكن تباعا للكلام اللى انا قولته دة الapi service اتكررت معايا ودة لان ال api service  هو شى مشترك بين كل الrepo اصلا يعنى كل ال repo حتستخدم ال api service طب ما انا نفس الكلام ليه استخدمها مرتين طب ما انا اعمل single ton للapi service لوحدها واستخدمها جوة اى single ton تانيه حنشاها فهمت اللى انا اقصدة فممكن اجى هنا قبل ما اعمل singleton لل home repo والكلام دة اقول هنا حعمل get it واقول registersingleton وال single ton حتبقى فيها ال apiservice واحط جواها الapi service وجواها dio وكدة زى الفل زى ما انت شايف فكدة انا مش مضطر انى استخدم الapi service فكدة انا بس محتاج انى احدد الservice بتاعتى اللى هى الapi service عن طريق انى استخدام الget it االنسخه اللى انا عملتها واقول .get وget بترجعلى حاجه انا انشاتها طبعا انا جوة المكان دة بحدد الحاجه اللى انت انشاتها وهى الapi service وكدة بالمنظر دة ونفس الكلام حاخد الline دة واكررة بداخل الsingleton الخاص بال auth repo بدلا من الapi serverice الموجودة بداخل register singleton فانا كدة بالفعل الدنيا بقت شغاله معايا بشكل جميل ومنظم جدا لان بقى عندى single ton نسخه واحدة من ال api service وعندى نسخه واحدة من ال home repo implementation بتستخدم  النسخه اللى انا انشاتها من ال api service ونفس الكلام عندى نسخه واحدة من ال home repo بتستخدم نفس ال api service اللى انا انشاتها من api service ونفس الكلام عندى نسخه واحدة من ال auth repo بتستخدم نفس ال api service اللى انشاتها قبل كدة فانا مش قاعد كل شويه انشا نسخ جديدة ونفس الوقت لو حصل تغيير هنا  بس حيسمع معايا فى كل الاماكن لو جيت هنا فى ال api service وقولتله خلى بالك ال api service دى حتستقبل حاجه جديدة يعنى مثلا final int x بالمنظر دة كدة وجيت هنا استقبلته فحيسمع معايا فى المكان دة فقط لا غير فحتلاقى ان الاماكن دى سليمه معايا فحيسمع معايا التغيير بداخل الsingleton الخاص بال api service فقط لا غير وكل اللى انا حعمله انى اقوله ان جمب الdio حدى قيمه لل x وهى 5 تمام كدة فالدنيا بقت بسيطه وسهله لان احنا ماشيين بشكل منظم نفس الكلام لو روحنا كدة فى المكان دة مش عايز ال home repo implementation بداخل ال main.dart انا عايز get it وهاتلى الhome repo implementation اللى انا انشاتها ونفس الكلام فى المكان دة امسحلى الhome repo implementation وهاتلى الget it الخاصه بال home repo implementation وزى ما انت شايف الموضوع بقى لطيف جدا فكدة اى تغيير حيحصل بداخل الservices دى اللى عملتها بداخل الsingle ton مش حياثر غير بداخل الsingle ton فقط فحروح على الapi service وامسح ال int x اللى ضيفتها دى وامسحها من الconstructor الخاص بال singleton وحيسمع معايا فى كل مكان وكدة بقى الموضوع سهل انى اعمل تغيير وبردة موضوع سهل انى استخدم ال services دى ودلوقتى انت ضامن انك عندك نسخه واحدة مش كل شويه عمال تنشا نسخه لا هى نسخه واحدة عندى وخلاص فطبعا get it صراحه tool لطيفه جدا يعنى تعتبر من الحاجات الجميله اللى انا بستخدمها على طول فى كل المشاريع لانها tool سهله اوى فاتمنى يكون الموضوع وضح معاك فيبقى get  it عبارة عن tool لطيفه جدا بيتقال عليها services locator او dependency ingection لان انا بعمل inject ل dependency معينه تمام وبعد كدة بستدعيها فى اماكن تانيه عشان ميعديش عليك ال concept دة وتحس انه غريب عليك وانت اساسا بتطبقه هنا بالفعل وهو بيحللك مشكلتين زى ما قولتلك المشكله انى انا عندى كل شويه نسخه عمال بعيدها والمشكله التانيه ان اى تعديل حيسمع معايا فى كل حته فبالتالى مش حيبقى شى ء لطيف وانا مش عايز كدة انا عايز اعمل تعديل مرة واحدة ويبقى كدة الدنيا خلاص وكدة احنا خلاص انتهينا من الget it يعنى انا كدة اتكلمت عن الget it بما فيه الكفايه بس اخر نقطه لان دى لقتها بعض الشباب بتعمل المشاكل دى لما باجى اعمل review على الكود وهى انك متحاولش تعمل get it لل featured books cubit يعنى متجيش تقول get it .registersingleton وتقولى ححطلك الfeatured books cubit وحتحطلى نسخه منه بداخل الinstance وتقولى featured books cubit وتعمل locate للget it .get home repo implementation وطبعا المنظر دة صح مش غلط ولو جيت تستخدمها بالاسلوب دة مش حيبقى فيه مشكله اصلا لانك انت فعلا كدة عملت single ton لل featured books cubit بس ححظرك بقى من نقطه هنا ان الbloc provider يا شباب مسؤول على انه يتخلص من ال cubit لما تنتهى منه وطبعا بما انك حاطط الcubit دة جوة الmaterial app فطبعا ال cubit دة عمرة ما حيتم الانتهاء منه لكن دلوقتى فلنفترض دلوقتى لو انا شغال بشكل سليم اكتر والمكان اللى محتاج ال cubit فعلا بعمله provide فيه يعنى مثلا فلنفرض فى الsearch اعتقد انى لو استخدمت ال cubit هنا فال search view كدة حنفتحها وحنقفلها فالمفروض ال cubit اللى بيستخدم جوة ال search view يتقفل معاها فطبعا لو انت مش مستخدم ال bloc provider فى المكان دة ومستخدمه فى ال material app بالتالى عمر ال cubit ما حيتقفل ودى نقطه وفلنفترض دلوقتى لو انت مستخدمتش ال bloc provider اصلا واستخدمت ال get it عشان تعملى ال cubit فكدة عمرة ما حيتقفل بردة ودة ليه لان ال bloc provider هو تلقائيا من نفسه بيقفل الcubit عشان كدة خلى ال bloc provider هو المسؤول على انشاء ال cubit متخليش ال get it لان الget it لو انشات ال cubit مش حتقفله حيفضل شغال معاك على مدار التطبيق بالكامل فطبعا دة شى مش سليم فعشان كدة استخدم ال bloc provider فقط فى انشاء ال cubits متستخدمش ال get it ودى نقطه حابب اتكلم عليها عشان بعض الاشخاص لقيتهم بيعملواها بس كدة يبقى احنا كدة اتكلمنا النهاردة عن كل النقط اللى حابيين نتكلم عنها وممكن النقط الاضافيه اتكلم عنها المرة اللى جايه وممكن اقول اننا عملناservice locator او   app   add get it to بس كدة فيه حاجه قبل ما نعمل commit الاول نسيت اعملها انى اعمل setup لل single tons بتاعتى لانى انا مستدعيتهاش اصلا يعنى الكود دة عمرة ما حيتنفد عشان كدة المفروض اروح على ال main.dart الاول واستدعى الsetup بداخل ال void main function وانا ممكن اغير اسم الfunction حخليها setup services locator واروح على الmain .dart بداخل الvoid main واستدعى الSetupServicesLocator
//          اهلا بكم يا شباب محاضرة جديدة من دورة فلاتر كنا المرة اللى فاتت اتكلمنا عن ال  get it تمام وبدانا نستخدمها بالفعل عشان نوفر بعض الservices ونبدا نستخدمها بسهوله وطبعا نستخدم نسخه واحدة مش اكتر من نسخه المفروض اننا كدة خلصنا كل حاجه من ناحيه الdata layer والmanager اللى هو الview model وعملنا provide لcubits فى الmain.dart طبعا خلى بالك فى نقطه مهمه هنا ان انت لو شايف ان الbloc دة مثلا او الcubit دة مثلا مش حتستخدمه غير فى screen معينه فيفضل انك متحطوش فى الmain.dart تحطه فى ال screen بتاعته بحيث ان لما الشاشه دى تتقفل يتم التخلص من الcubit بتاعك ميفضلش شغال معاك طول التطبيق لان بما انه جوة ال material app او فوق ال material app فحيفضل عايش معاك طول ما انت فاتح التطبيق فدى نقطه خلى بالك منها وانت شغال بردة لكن بما انى شغال فى الhome فال home حتفضل شغاله معايا طول التطبيق فعلا فعمرها ما حتتشال مش  حتروح لشاشه وتتخلص من الhome لانه ممكن يرجع للhome فبالتالى ال home حتفضل عايشه معايا فعشان كدة مش فارقه كتير بصراحه حطيتها فى الشاشه بتاعتها او حطيتها فوق ال material app مش فارقه لانها هنا مش فارقه خالص تمام فبالتالى حسيبها فوق ال material app انا ممكن دلوقتى ابتدى واكممممل هل الدنيا شغاله ولا لا واجرب اعرض البيانات بتاعتى فتعالى كدة نروح على الroutes بتاعتنا فحروح على الhome view فحروح على الlist view الخاصه بالfeatured books وابتدى استخدم ال bloc builder بتاعى او ال bloc consumer او ال bloc listener على حسب انت حتعمل ايه محبش انى انا استخدمه فى المكان دة اى فوق ال list view جوة الشاشه الخاصه بال home view body لانى بحث ان منظرة مش لطيف خالص لكن انه يبقى جوة ال list فحيبقى الطف يعنى لانه بي manage الجزء دة اخاص بال featured books list view فيبقى عايش فى الجزئيه دى مش لازم اخليه يعيش فى جزئيه تانيه يعنى والاقى ناس بتتلخبط لان هو بي manage الجزئيه دى فيفضل عايش فى الجزئيه دى فتعالى نwrap لل sized box جوة ال bloc builder لان انا واضح انى حبنى حاجات مختلفه بدايه من انى ب fetch ال data فالمفروض حيبقى فيه loading بيظهر لحد لما الdata ترجع فاعرضله الdata او ميرجعش الdata فبالتالى اعرضله رساله تقوله ان فيه مشكله فبالتالى فيه اكتر من حاجه ممكن تتعرض فبالتالى لازم احط الsized box  جوة bloc builder اصلا وممكن كمان تحطه جوة bloc consumer لو انت حابب تنفد مجموعه من الاكواد لكن انا شايف ان ملوش لازمه فى المكان دة فحستخدم ال bloc builder فقط فحستخدم هنا ال featuredbookscubit وهنا حستخدم الfeatured books state بالمنظر دة وحلو اوى وطبعا نعمل import لل bloc builder وبعد كدة ححط الreturn دى جوة if condition عشان اعمل check على الstates فانا عندى اول state فى حاله الsuccess حرجع الListView بتاعتى تمام اوى طب لو كانت فى حاله الfailure فساعتها حقول else if state is FeaturedBooksFailure اى ان فى حاله الfailure حرجع error message وال error message اكيد حتبقى widget فانا ساعتها احب انى اعمل widget customize للموضوع دة عشان لو فى الاخر حبيت انى اغير من شكل الerror message  اللى بيتعرض  فاغير فى مكان واحد يسمع معايا فى كل الاماكن ففى folder ال widgets ممكن اعمل widget جديدة حسميها مثلا custom error_widget.dart وانشا stateless widget كدة تسمى CustomErrorWidget ممكن نخلى مثلا عبارة عن text widget مثلا وحتبقى عبارة عن error حنستقبله طبعا فحقول final String errMessage وتعالى نستقبلها فى الconstructor ونحطها فى المكان دة كدة جوة الtext وحقوله errMessage على طول وحديله الstyle حخليه Styles.textStyle18 فكدة فى حاله الfailure ممكن اعمل return على طول اقوله ان هنا حيعمل return ل CustomErrorWidget وابعتلها ال state الخاصه بال errorMessage بعد كدة حقوله else بقى انى حعمل loading indicator عادى جدا ودة لانى مش مهتم اعرضله حاجه تانيه ففى الinitial انا عمرى ما حوصل للمكان دة غير وانا ب load ال data اكيد فاكيد عملت الrequest بتاعى فعمرها ما حتكون initial وانا عامل handle لل success وعامل handle لل failure فمش حيتبقى غير الloading فى الحاله دى حعرضله loading indicator فحقوله return CircularProgressIndicator بالمنظر دة كدة واحط const جمبها وكدة تمام وزى الفل وطبعا ممكن احطها فى الcenter عشان تبقى جوة الcenter بردة فحعملها wrap واحطها جوة الcenter widget ونفس الكلام حنروح ننشا widget خاصه بالloading indicator عشان الloading indicator ممكن نستخدمه فى اماكن كتيرة فممكن هنا نقول custom_loading_indicator الى جانب انك ممكن تغيرة اصلا الى جانب انك ممكن تغيرة اصلا انك ممكن تغير الloading indicator دة خالص فبالتالى انت عايزة يسمع معاك فى كل الاماكن فحاخد ال loading indicator دة copy واحطه فى المكان دة فحعمل statelesswidget الاول وحسميها custom loading indicator وححطها فى المكان دة وحعمل import للmaterial.dart وتعالى نخليها const وحنستدعيها بداخل return الخاص بالelse statement تمام جدا دلوقتى النقطه اللى انا بكلمك فيها انى دلوقتى عايز ابتدى واعمل triggered لل request بتاعى فانا حبتدى واعمل triggered من مين ؟؟ فالمفروض طالما انت عندك يوجد request بيعمل fetch لdata فى شاشه فالمفروض ان الrequest يبقى موجود فى نفس الشاشه يعنى الصح انى اروح على الhome view مثلا واخليها statefulwidget واحط ال request جوة ال stateful widget ودة الصح لان الrequest مش معتمد على حاحه يعنى مفيش button مثلا فى الsplash view بتقولى خلى بالك انت حتعمل fetch للبيانات فعشان كدة انت حطيته هنا يعنى انا مثلا لو عندى فى الsplash view لو عندى button بيخلينى اfetch الfeatured books فواضحه جدا ان الrequest حيتحط فى المكان دة لان دة button حضغط عليه حي fetch البيانات واروح على الشاشه الجديدة حلاقى البيانات والموضوع واضح يعنى لكن طبعا هنا لا هنا انا مجرد ما اروح على الشاشه المفروض البيانات تبقى عندى ولا button ولا اى حاجه فبالتالى المفروض الrequest يبقى عايش جوة الhome view عندى  فجوة الstateful widget المفروض انى احطه جوة الinitstate ودة الصح طب انت لو مش حابب تستخدم stateful widget عشان حاجه بسيطه زى كدة ساعتها بتستخدم الspead operator فممكن اروح على main.dart واقوله على طول بمجرد ما تنشا الcubit دة عن طريق ..اقوله استدعيلى الfetchFeaturedBooks وكدة اللة انا عملته دلوقتى انى انا بعد ما انشات النسخه دى نفدت ال fetchFeaturedBooks عليهها لكن لو نقطه واحدة يبقى انت بتعمل return لل line دة فدة معناة ان اللى حيرجع من هنا هو ال return اللى راجع من ال method دى دة لو نقطه واحدة فدى بترجعلى void فبالتالى حيقولك future void is not sametype من الحاجه اللى هو بيستخدمها ودة لانك انت كدة بترجع الحاجه اللى جايه من الfeatured books لكن انا عايز استدعيها بس  مش اكتر فطبعا فى المكان دة بستخدم النقطتين دول عشان اقوله بعد لما تنشا نسخه الcubit الخاصه بال featured bookscubit بال service بتاعته نفدلى الكود دة فكدة بقت الدنيا واضحه خلاص فكدة واضح انى لما باجى انشا الcubit بستدعى الmethod على طول ودة افضل مكان احط فيه ال method بتاعتى الخاصه بال request ويفضل محطهاش فى الsplash view مش غلط لكن مش اسلوب صح وتعالى كدة نعمل restart ونشوف ايه اللى حيحصل طبعا خلى بالك احنا مضيفناش ال bloc observer والمفروض اننا نضيف ال bloc observer عشان نشوف الstates يعنى نعرف هو فيه failure ولا لا بس حنضيفها المحاضرة القادمه وظهرلى error بيقولى ان فيه مشكله عندنا فى الmodel بتاعنا فحنروح على الfeatured books كدة ونروح على الimplementation  كدة فممكن نستخدم debugging tool فممكن المشكله هنا تبقى فى from json فحدور فى الmodel على حاجه فيها list<String> لان احنا عندنا بيانات كتيرة جدا فممكن نتاكد عن طريق debugging tool عشان نعرف المشكله جاىه منين بالظبط فحروح على الfrom json ةابتدى احط break point وبعد كدة اعمل run للكود من الاول لغايه لما يfetch البيانات ويقف هنا فهو بالفعل عمل fetch للبيانات من خلال انه عمل request وجاب البيانات بشكل سليم لكن الmodel دات نفسه فيه مشكله او هى مشكله بسيطه يعنى مش مشكله صعبه فتعالى كدة نوصل للمشكله فتعالى كدة نمشى line ب line الموضوع سهل جدا يا شباب لحد لما نعرف المشكله جايه منين  فلقيت ان المشكله موجودة فى الline اللى وقفنا فيه وهو الvolume info واحنا مطلعناش برة الline دة فكدة المشكله جايه من الvolume info فكدة المشكله جايه من الvolume info فتعالى كدة ندخل عليها ونحط break point فى المكان دة فكدة حنشيل الbreak point من الbook model وحدخل على الfrom jsonالخاص بال volumeinfo احط الbreak point بتاعتى فانا  دلوقتى بعمل debugging دلوقتى مقداميش حل تانى فدلوقتى احنا بن handle ال exceptions بشكل سليم يعنى كدة اى exception عملناله handle واتعرضلنا يعنى فكدة متقلقش من النقطه دى الfailures بتت handle عادى مفيش اى مشاكل فحلاقى انها عملت fetch عادى فممكن نمشى خطوة بخطوة فكدة عرفنا ان المشكله فى الauthors زى ما انت شايف هو طبعا معترض بقى فتعالى كدة نشوف الرساله بقى من تانى كدة بقى عرفنا الline اللى عملنا مشكله وهو الauthors line فتعالى نعمل run ونشوف المشكله ايه وهو بيقولك ان الlist of dynamic يعنى معنى كدة ان الdata اللى جايه من الapi list of dynamic وزى ما انت شايف بالفعل دى اللى عامله المشكله لان انت عندك هنا الauthors عبارة عن list of string فبالتالى المكان اللى بتستقبل فيه البيانات هنا فبالتالى المكان اللى انت بتستقبل فيه البيانات هنا جايالك list of dynamic فبالتالى هو معترض على الموضوع دة بيقولك ان ال  list of dynamic is  not a subtype of list of string فى الtypecast يعنى هو مش عارف يعمل type cast بداخل الfrom json الخاص بال volume info فى الauthors وبالتالى انت عندك حلين ممكن تعملهم الحل الاول ودة الابسط انك تخلى الauthors يكون dynamic وخلص الموضوع على كدة  لان بمجرد ما تخلى دى dynamic مش مححتاج تعمل type cast والبيانات اللى حتجيلك حتتخزن زى ما هى بس طبعا دة شىء مش لديد خالص محبش انى اعمل كدة الحل التانى انى استقبل البيانات كdynamic فحقوله هنا ان البيانات اللى جايالى هى من البدايه اساسا حستقبلها ك dynamic لان انا مش عارف الحاجه اللى جايالى اصلا list ولا لا فانا لسه بعمل parse ليها فبالتالى حقول استقبلها على انها list of dynamic ودة فى البدايه خالص فهو بالفعل حيلاقى البيانات جاياله على هيئه list of dynamic فانا بقوله استقبلها على هيئه list of dynamic فبالتالى مش حيعترض كدة الدنيا حتبقى شغاله بشكل سليم بعد كدة ممكن اعمل cast لكل حاجه بقى بعد كدة ممكن اعمل cast لل list of dynamic دات نفسها يعنى بعد لما اخليها list of dynamic الاول ابتدى واعملها type cast فى المكان دة  فاجى فى المكان هنا اعملها .cast فى المكان دة بس حنحط ? الاول  لان البيانات ممكن تكون ب Null فممكن تجيلنا ب Null فى بعض الاوقات بعد كدة فاضل ان جوة ال cast اقوله ال type اللى ححطه جوة المكان دة يعنى انا عندى list of dynamic فعايز اخليها list of string فكدة انا بعمل cast لكل البيانات اللى بداخل list of authors ال dynamic واحولها على هيئه String فاعتقد ان دى كدة تحللنا المشكله يعنى تعالى اقولك انا عملت ايه تانى عشان متتلخبطش انا فى البدايه مش عارف الauthors دى عبارة عن ايه فبالتالى قولتله استقبله على هيئه list of dynamic بعد كدة ال list دات نفسها عملتلها cast حولتها لل list of string بس الموضوع بكل البساطه دى تعالى نعمل run كدة ونشوف هل حتحللنا المشكله ولا لا ولا فيه مشكله  حنقابلها  تانى هو تقريبا المشكله دى حتحصل فى اى حاجه معمولها cast على هيئه list of string بس هو ادانى نفس الerror قالى ان  list of dynamic is not a subtype فعايزين نتاكد ان المشكله مش فى الline دة يعنى عايزين نتاكد ان احنا بالفعل حلينا المشكله اللى كانت عندنا فى الvolume info بداخل الauthors فيمكن جايه من مكان تانى فحلاقى ان عندى نفس الكلام فى الcategories فانت عايز تطبق ان فى اى مكان هو عامل list of string لازم حنطبق الكلام دة فتعالى كدة نطبق نفس الحركه دى بالظبط فتعالى نخلى الcategories استقبلها على هيئه list of dynamic وبعد كدة الlist بالكامل حعملها cast على هيئه String واحط فى الاول علامه استففهام وحدور هل فيه اى cast ب list of string فى الfrom json الخاص بال volume info فحلاقى ان كدة خلصت فتعالى نروح على باقى الmodels ونصلح فيها اى list of string نحولها ل list of dynamic فى الfrom json الخاص بكل model فحلاقى ان مفيش  list of string فى الmodels  عندى فحلاقى انها عندى كدة اشتغلت كدة هو عمل fetch للبيانات بشكل سليم فكانت المشكله سهله مش مشكله صعبه ومشينا على الخطوات لحد لما حليناها فزى ما انت شايف الموضوع سهل بس كدة بالفعل عملنا fetch للبيانات وكدة الدنيا شغاله بشكل لديد جدا ممكن نبتدى ونعرضها اصلا فكدة حخلى انى اعمل display لل data فى المحاضرة اللى جايه فكدة ممكن نقول اننا عملنا display لل data اللى هى الdisplay featured books
//  اهلا بكم يا شباب محاضرة جديدة من دورة فلاتر كنا المرة اللى فاتت بدانا بالفعل نعمل display لل data لكن طبعا مجرد اننا عرضنا الlist view فى حاله الsuccess مش اكتر لكن لسه الitem دات نفسها مش بتاخد اى حاجه فالمفروض انى دلوقتى حبتدى وااعرض البيانات فى الitem وزى ما انت شايف دى مجرد image مش اكتر فممكن نستقبل هنا الimage فحعرف متغير جوة الitem واسميه imageurl نوعه string وبعد كدة اخدها فى الconstructor وطبعا زى ما انت شايف مجرد ما عملت كدة الerror سمع معايا فى اكتر من مكان لو تلاحظ يعنى سمع معايا فى الbooks list view وسمع معايا فى الfeatured اللى انا بشتغل عليها دلوقتى وسمع معايا بداخل مكانين تانيين انا مش حشتغل فيهم اصلا فطبعا زى ما انت شايف ان سهل انى احلها بالنسبه للlist اللى انا شغال عليها دلوقتى ودة لان انا معايا الdata لكن بالنسبه للمكانين التانيين فانا مش معايا data اصلا فعشان كدة ممكن اجيب اى url من على النت لاى صورة واستخدمها بداخل المكان دة ودة اللى انا حعمله دلوقتى فكدة انا بالفعل خدت copy من اى url من على النت لاى صورة وممكن استخدمه فى المكان دة ودة اللى انا حعمله دلوقتى فحاجى جوة ال similar books list view واحط الurl الخاص بالimage اللى من على النت وححطه بداخل الimageurl وحديلها الimageurl ونفس الكلام حعمله فى الitem التانيه وهى الbooks details section وبعد كدة حاجى هنا بردة بداخل الcustom book image وحديله image url بتاعها كدة فاضل انى اروح على الlist view اساسا واجى فى المكان دة واديله الimageurl بتاعته وطبعا الimage حعملها access عن طريق الstate الخاصه بالbooks واديله الindex عشان اديله بيانات الitem اللى انا فيها دلوقتى وحقوله .عشان اديله الimage فبالتالى عندك اكتر من حاجه عندك access info وعندك search  وعندك sale وعندك volume فالimage تقريبا موجودة فى الvolume فحتلاقى انك عندك بالفعل فيه imagelinks فممكن نستخدمها وحلاقى عندك thumbnailوهنا حتلاقيه معترض لاكثر من سبب منها انى مستخدم const فى الpadding وحتلاقيه معترض لان القيمه اللى هى الvolume info دى nullable يعنى عادى ممكن تاخد قيمه null ودة طبعا شىء منطقى لان الextension اللى انت بتستخدمها دلوقتى بتستقبل بيانات من الbackend فهى مش عارفه هل القيمه دى حتكون ب null ولا لا فهى مش عارفه الموضوع دة فبالتالى بتعتبر كل القيم اللى جايالك ممكن تكون ب null ودة شى منطقى جدا يعنى لان هى مش عارفه لكن انت المفروض فى الطبيعى لو انت بتتعامل مع شركه او حاجه زى كدة فانت معاك الشخص اللى بيبنى الapi فانت عارف القيمه دى ب null ولا لا فانت بتقوله مثلا هل القيمه دى ممكن ترجع بnull فهو بيقولك لا لو بترجع ب null فهو بيقولك اة فانت بالتالى انت عارف النقطه دى فتقدر تيجى فى المكان دة وتعمل التعديل فانا هنا فى الvolume info بيرجع بnull ولا لا فتقريبا لا يعنى انا لو بصيت على الvolume info response كله فلقيت انه دايما بيرجع  فيها بيانات ودايما بيرجع الthubnail والsmallthubnail فبالتالى على الاغلب القيمه دى مش ب null عشان كدة مش حخليها nullable اصلا وبما انها مش nullable فحعمل التعديلات فى الresponse الحاص بال volume info وفى الbook model فى الجزئيه الخاصه بال volume info يعنى هنا بداخل الresponse الخاص بال book model اللى هى bookmodel.from json بيقولك بيعتبر انها لو كانت nullable اهو فبيعمل check عليها الاول يشوفها لو كانت nullable بيرجعلها القيمه null عادى جدا ولو مكنتش nullable بيعملها parse فى المكان دة فانا طبعا حاخد الline بتاع الvolume info copy واحطه بدل وححطه بدال الجزءيه الخاصه بال check response if nullable or not وطبعا انا عملت الحركه دى لان انا متاكد ان البيانات اللى حترجعلى من الresponse الخاص بال  Volume info  مش ب null لكن لو انا شاكك ان ممكن الresponse يكون ب null فسيها زى ما هى واتعامل على الاساس دة هناك اشوف انا ححل المشكله دى ازاى لو كانت ب null حعرض قيمه مختلفه عشان ميحصلش معايا مشكله فى التطبيق بتاعى لان ممكن فى بعض الاوقات فعلا ترجعلى القيمه ب null لكن دى بتكون مشكله من الapi فبيحولها والتطبيق يشتغل لكن دى حاله غير القيمه دى بترجعلك بnull فى بعض الاوقات يعنى دة العادى ان ممكن القيمه ترجعلك بnull فى بعض الاوقات مش مشكله فى الapi يعنى ممكن فى الapi يحصل مشكله فيرجعلك قيمه عمرها ما بترجع ب null بس دى حاجه حيحلها والتطبيق حيشتغل لكن ممكن فيه بعض القيم اللى عادى انها ترجع بnull فهو بيقولك اة دة option وممكن ترجعلك بnull لكن القيمه اللى هى ال VolumeInfo دى مش حترجع بnull اصلا فبالتالى مش لازم اخليها nullable وبما انها مش nullable فلازم اخليها required بداخل الbook model  constructor عشان تتحل معانا فطبعا بص انا استخدمت الextension عشان اعمل generate للmodel بالفعل لكن طبعا انا عملت شويه تعديلات من عندى عشان كدة الtools دى يا شباب بتسهل عليك شغلك لكن مش بتاخد دورك لازم تكون فاهم عشان تعمل التعديلات دى والتعديلات دى عشان تعملها اصلا لازم تبقى فاهم انت بتعرف تعمل الكلام دة ازاى طبعا انت كدة ظبطت  الvolume info  ولسه بردة لما تدخل حوة ال volume info  على الimagelinks بردة نفس الكلام حخليها مش ب null فبالتالى حاجى فى المكان دة كدة واخد ال line دة copy واحطه فى المكان الخاص بال imagelinks response فى ال volume info .from json ونفس الكلام حخليها required بقى ونفس الكلام حروح على الimage links بردة وحخلى ال 2 parameters ب null فحخليه مش ب null وبعد كدة حخليها ك string عادى ويبقى عندى هنا required لل smallThumbnail,thumbnail ماخدش منى وقت وزى ما انت شايف ححلى المشكله فى الList view اللى عندى هنا فحروح على الfeatured list view  وحلاقى ان الerror حدف فى المكان دة فدلوقتى ممكن اروح على الcustom book image وابتدى اعرض الصورة بالفعل فممكن اخد الimage url هنا بس خلى بالك ان دة assrt image مش network image فبالتالى تعالى نمسحها كدة اصلا ونخليها network image بالمنظر دة واحط هنا الimage بتاعتى عن طريق انى ححط الimage url وحنشيل الconst طبعا من هنا واعمل ctrl s كدة وزى ما انت شايف المفروض حيعرضلى الصور دلوقتى فبالفعل عرضلى الصور بالفعل وطبعا ممكن اشيل الbackground color دلوقتى وكدة بالفعل احنا بنعرض الصور زى ما انت شايفها فكدة المنظر بقى لطيف والدنيا بقت لطيفه جدا بس طبعا فيه exception بسبب الrange وهو الitem count فحنروح لل listview.builder واديلها ال state.books.length وكدة الerror اتحل فاخر نقطه حابب اتكلم فيها فهى ان لو جاى اعمل scroll ناحيه الشمال فحتلاقى ان فيه اضاءة كدة بتظهر ودى مش لطيفه خالص يعنى مش بحبها تظهر وانت بتستخدم التطبيق اصلا فبالتالى ممكن احل المشكله دى عن طريق ان احنا بنستخدم physics واخليها const BouncingScrollPhysics() ودى لطيفه جدا بصراحه بتخلى شكل الscroll يكون جميل بجانب انها بتحللك مشكله كدة ساعات بتظهر معاك فدة شى لطيف انك تستخدمها عامه خصوصا فى الhorizontal list view وفى الvertical بردة وكدة احنا عملنا display لل images بس مش اكتر وعملنا display لل featured books list view
// اهلا بكم يا شباب كنا المرة السابقه بدانا نعمل display لل items بتاعت الlist view زى ما انت شايف والدنيا شغاله معانا بشكل سليم بس طبعا انا قولتلك ان فيه مشكلتين تقريبا فى اننا نعرض الصور اللى جايه من على الانترنت بالمنظر دة المشكله الاولى انى لو عملت restart للتطبيق فحتلاحظ انك عندك لو مستخدم ال network image حتلاقى ان الصور بتظهر مرة واحدة بمجرد ما  يتعمله load بتظهر على طول يعنى بمجرد ما يتعمله load بتظهر على طول ودة شى مش كويس لان بما ان الdata اتعملها load خلاص لكن لسه الimage متعملهاش load فلما الimage يتعملها load تظهر على طول و المشكله التانيه يا شباب فلنفترض لاى سبب من الاسباب ال ui اتعمله rebuild فطبعا الdata موجودة وكل حاجه لكن خلى بالك بما انه اتعمله rebuild احنا حن fetch ال image دى من الاول فمعنى انى حعملها fetch من الاول معناها انى ححملها من الاول وطبعا دة بيستهلك من الdata يعنى انت دلوقتى عندك باقه نت فبالتالى انت كدة بتستهلك من باقه النت طبعا هو استهلاك بسيط جدا لكن خلى بالك الاستهلاك البسيط دة لما يتكرر كتير جدا بيعمل حاجه كبيرة فطبعا احنا عايزين نتفاى المشاكل دى يعنى احنا عايزين نخلى التطبيق بتاعنا شغال على قد ما يقدر بشكل كويس جدا فدى المشكله التانيه وخلى بالك فيه مشكله تالته فهى وانت بتload ال image فلنفترض دلوقتى حصل failure يعنى مقدرناش نload الimage والurl كان بايظ اصلا فالمهم زى ما انت شايف رمى exception على طول طبعا والدنيا اتبهدلت معانا خالص لانه مقدرش يعمل load لل url دة لان الurl دة غلط فبالتالى دة كدة مشكله بالنسباله فطبعا دى 3 مشاكل ممكن تقابلك لو انت بتستخدم الnetwork image العاديه بتاعتك وال3 مشاكل  انت عايز تحلهم فطبعا انت لو دورت على ازاى تحلهم حتلاقى بالفعل فيه package وهى من الpackages المهمه اللى بتنزل من خلال flutter team تسمى cached network image وال package دى بالفعل بتحللنا ال 3 مشاكل دول فحنروح نعمل search على الpackage دى اللى ههى ال cached network image فظهرتلى اول واحدة اهى حندخل عليها وحلاقى ان بالفعل واخدة rate عالى ومعنى كدة انها package مشهورة جدا وال package استخدامها بسيط جدا هو بيوفرلك widget تسمى cachednetwork image والwidget بتاخد image url وكمان بنديلك امكانيات لحاجات تانيه كتير زى الerror widget ودى widget بتعرضها فى حاله انه يوجد failure وهو بيعمل load لل url يعنى وعندك بردة place holder  ودى عبارة عن widget بتعرضها فى حاله الloading اى انه وهو بي load ال image ممكن تعرض indicator وحتى لو مححطهاش هو لما بييجى يظهر الصورة بيظهرها على شكل fading كدة لطيف جدا بيبقى شكله كويس جدا فتقدر تستخدمه على طول فتعالى نعمل import لل package دى عندنا فى التطبيق فتعالى ناخد الاسم بتاعها وحنضيفها بداخل الpub spec .yaml بس خلى بالك كدة مش كفايه انا كمان محتاج بعد لما اضيف الpackage اقفل التطبيق واخليه ي run من الاول اساسا وزى ما انت شايف عملت run للتطبيق وطبعا رمى exception معانا بسبب ال string اللى احنا حطينه فى الnetwork image ك url دة فتعالى دلوفتى نستخدم ال widget بتاعتنا خلى بالك انها widget يعنى مينفعش احطها فى المكان دة فانا ممكن استخدم ال widget على طول لان الwidget هى اللى بتوفرلك انك تستخدم ال placeholder  او الerror widget فساعتها حشيل الcontainer خالص اللى بيحتوى على الnetworkImage وحنستخدم بدلا منه cached network image وهى بتاخد image url ودة خلى بالك required يعنى دة لازم حتاخدة تمام لكن الحاجات التانيه option بس ليه هو مش متعرف على الcached network image  لانى معملتلهاش import وكدة لو عملت run للتطبيق حلاقى ان الصصور بتظهر معانا بشكل لطيف فحتلاقى ان الlist view items ظهرت معانا بشكل لطيف وظهرت معان بعمليه fading لطيفه جدا ودى حلتلنا اول مشكله وهى ان شكل الصورة لما بتظهر بتظهر بشكل كويس المشكله التانيه بردة اتحلت وهى ان خلى بالك جايه من اسمها cached فافتكر ان cached يعنى حاجه بcache عندى وبخزنها عندى فهو من الاخر كدة لما بيجيب الصورة بيcache كمان عشان لما تعرضها تانى كمان شوبه تظهرلك على طول فمعنى كدة ان مش كل شويه حيقعد يحمل الصورة دى لا هو حيحملها مرة واحدة ويعملها cache وبعد كدة يعيد استخدامها فبالتالى انت كدة بتوفر من الdata اللى بيستهلكها الuser يعنى لما الuser ييجى كدة يبص على التطبيقات اللى بتستهلك data كتيرة جدا فانت عارف انك عندك الامكانيه انك تعمل حاجه زى كدة تشوف ايه التطبيقات اللى بتستهلك data اكتر وساعات الuser بيمسحوها لما بيلاقى انه بيستهلك data كتير جدا فيلاقى ان التطبيق بتاعك مش بيستهلك كتير لان انت فعلا بتعمل الحاجه بشكل سليم زى ما انت شايف شكلها فى الظهور كويس جدا حلو اوى وطبعا خلى بالك هى واخدة حجم صغير لان انت مش مخليها تاخد المساحه المتاحه ليها احنا كنا فى الcontainer بتاعتنا وكنا حاطين decoration image وال image اللى حطينها بنخلبها تfit فى المساحه بتاعتها وهنا نفس الكلام احنا عندنا fit موجودة ممكن تستخدمها على طول يعنى ممكن اجى فى المكان دةالخاص بال cachednetworkimage  اقول fit  واقوله boxfit.fill فحتاخد المساحه بتاعتها المتاحه بس محتاج اديها ال radius بتاعها فممكن اروح فوق ال aspect ratio واقوله انا عايز احطك حوة الcliprrect عشان اديله border radius مش اكتر واقوله BorderRadius.circular وحيكون 16 وكدة احنا حلينا المشكلتين وهما الظهور بتاعها والمشكله التانيه ان الdata لما تعمل load احنا بنعملها cache والمشكله التالته اللى كنت قولتلك عليها وهى لو فيه غلط فى الurl فايه اللى حيحصل فعرضلك على الشاشه بالفعل ان فيه غلط فى عرض الصورة وهنا ممكن تلجا لحاجه اسمها errorwidget يعنى انا بقوله فى المكان دة انى حعرض errorwidget والerror widget دى انا ممكن احط اى حاجه يعنى انا ممكن احط IconWidgetوحنقوله عيارة عن Icons .access alarm وطبعا هو مديلى error لان خلى بالك المفروض دة builder مش بياخد ال widget على طول يعنى فانا المفروض باخد الbuilder بتاعه فتعالى نستخدمه فيظهرلى على طول يعنى )context,url,error وبعد كدة يظهر معابا وبعد كدة اضيف ال icon فانت المفروض انك حتلاقى ان الicon ظهرت فى المكان دة زى ما انت شايف ودة طبعا شىء كويس يعنى يعنى هو فعلا بيظهرلك error widget فى حاله انه مقدرش ي load ال url فمتقلقش خالص هو الurl ظهرلك بشكل سليم ولا لا ودى حاجه متقلقكش خالص لان خلى بالك بتحصل كتير جدا ان ال url تجيلك فيها مشاكل وبتحصل كتير اوى كمان فبالتالى نقطه ان انت تعمل handle للموضوع دة دى حاجه مهمه جدا وطبعا دى widget لا غنى عنها يعنى حرفيا ال widget دى اكيد حتستخدمها فى التطبيق بتاعك ودى بسنبه 90% حتستخدمها فاكيد حتعرض صور جايه من على النت الا لو تطبيق بسيط جدا وكدة احنا اتكلمنا عن النقطه دى وكدة احنا خلصنا كلام يعنى انا اللى يهمنى انك تعرف انا بستخدم الcached network image وبستخدمها ليه وامتى ؟؟؟ بستخدمها فى عرض كل الurl اللى جايه من على النت طبعا صور وموضوع لديد جدا وسهل وطبعا فى المكان دة بحط الerrorwidget بتاعتى وممكن كمان احط place holder وممكن احط اى widget فى المكان دة فححط circularprogressIndicator وطبعا انا هنا بحط loading يتماشى مع الdesign بتاع التطبيق فحعممل restart للتطبيق ونشوف المنظر حيبقى عامل ازاى فطبعا حلاقى اول حاجه الcircularprogressindicator بتاع الlist view item بعد كدة حنلاقى كدا circular indicator لكل الصور ففعلا هو ظهر فعلا بس شكله مش لطيف خالص لان حجمه كبير جدا اعتقد انى لو عملت scroll من اليمين كدة فالمفروض حيظهر معاك لو فيه صورة لسه متحملتش وانت طبعا لو عايز تظبطها ممكن تصغرها بانك تخلى الcircular progress indicator فى الcenter ودة حيظبطلك الموضوع او تخليه فى sized box وتديله height w width بس لو خليته فى الcenter المفروض انه حيظبط الموضوع على طول وزى ما انت شايف دة شكل الindicator شايف منظرة عامل ازاى منظر لطيف يعنى مش سىءومعتقدش انه كان منظر سىء فكدة دة المنظر بتاع الimage طبعا انت ممكن تحط حاجه الطف من كدة كمان يعنى ممكن تحط animated circular تكون حاجه customize للتطبيق بتجيلك من الdesigner مش انت اللى بتعمله وتحطها فى المكان دة فبيبقى شكلها لطيف جدا عندك اكتر من طريقه وطبعا فى حاله الerror ممكن تغير من الشكل شويه يعنى ممكن ماشى انا مش شايف ان علامه التعجب حتبقى وحشه واسمها error وزى ما انت شايف دة منظرها فاظن منظرها كويس جدا ودة منظر واضح وصريح وكدة انت بتعمل handle لكل حاجه الloading بتعمله handle والerror بت handle والimage url بتظرها عن طريق الcached network image ودى بتخلى شكل الصورة جميل وفى نفس الوقت بيعمل cache لل data بحيث انها بتبقى اتخزنت الصور عندك بدل ما كل شويه يعمل load لل data من اول وجديد ودة حيستهلك منك كuser data كتيرة بس انا شايف انك مش محتاج الcircular indicator بصراحه لان شكله مش لطيف اصلا يعنى هى لما تظهر بfading كدة لوحدها بيبقى شكلها افضل وتعالى نرجع الimage url عشان يبقى شكلها مظبوط وزى ما انت شايف كدة بيبقى شكلها لطيف وممكن نحط الcircular progress indicator لو image url موجود وطبعا لو فيه indicator شكله افضل حيبقى افضل من كدة كمان بس انا شايف حاليا ملهوش اى لازمه فتعالى نشيله خالص لان مش عاجبنى المنظر بصراحه وكدة كل اللى احنا عملناة اننا استخدمنا الcached network image 
